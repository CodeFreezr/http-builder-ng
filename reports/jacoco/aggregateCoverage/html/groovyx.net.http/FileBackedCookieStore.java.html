<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FileBackedCookieStore.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">http-builder-ng</a> &gt; <a href="index.source.html" class="el_package">groovyx.net.http</a> &gt; <span class="el_source">FileBackedCookieStore.java</span></div><h1>FileBackedCookieStore.java</h1><pre class="source lang-java linenums">/**
 * Copyright (C) 2017 David Clark
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *         http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package groovyx.net.http;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.net.HttpCookie;
import java.net.URI;
import java.net.URISyntaxException;
import java.time.Instant;
import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.ConcurrentModificationException;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.function.Consumer;

class FileBackedCookieStore extends NonBlockingCookieStore {

<span class="fc" id="L41">    private static final ConcurrentMap&lt;File,File&gt; inUse = new ConcurrentHashMap&lt;&gt;(5, 0.75f, 1);</span>
    
    private static final int NUM_LOCKS = 16;
    private static final String SUFFIX = &quot;.properties&quot;;
    
    private final File directory;
    private final Object[] locks;
    private final Executor executor;
    private final Consumer&lt;Throwable&gt; onException;
    
<span class="fc" id="L51">    private volatile boolean live = true;</span>

<span class="fc" id="L53">    public FileBackedCookieStore(final File directory, final Executor executor, final Consumer&lt;Throwable&gt; onException) {</span>
<span class="fc" id="L54">        this.onException = onException;</span>
<span class="fc" id="L55">        ensureUniqueControl(directory);</span>
<span class="fc" id="L56">        this.directory = directory;</span>
<span class="fc" id="L57">        this.locks = new Object[NUM_LOCKS];</span>
<span class="fc bfc" id="L58" title="All 2 branches covered.">        for(int i = 0; i &lt; NUM_LOCKS; ++i) {</span>
<span class="fc" id="L59">            locks[i] = new Object();</span>
        }

<span class="fc" id="L62">        this.executor = executor;</span>
<span class="fc" id="L63">        readAll();</span>
<span class="fc" id="L64">    }</span>
    
    public FileBackedCookieStore(final File directory, final Executor executor) {
<span class="pc" id="L67">        this(directory, executor, (t) -&gt; {});</span>
<span class="fc" id="L68">    }</span>

    private static void ensureUniqueControl(final File directory) {
<span class="pc bpc" id="L71" title="1 of 2 branches missed.">        if(null != inUse.putIfAbsent(directory, directory)) {</span>
<span class="nc" id="L72">            throw new ConcurrentModificationException(directory + &quot; is already being used by another &quot; +</span>
                                                      &quot;cookie store in this process&quot;);
        }
<span class="fc" id="L75">    }</span>
    
    private void withLock(final Key key, final Runnable runner) {
<span class="fc" id="L78">        Object lock = locks[Math.abs(key.hashCode() % NUM_LOCKS)];</span>
<span class="fc" id="L79">        synchronized(lock) {</span>
<span class="fc" id="L80">            runner.run();</span>
<span class="pc" id="L81">        }</span>
<span class="fc" id="L82">    }</span>

    private void deleteFile(final Key key) {
<span class="fc" id="L85">        final File file = new File(directory, fileName(key));</span>
<span class="pc bpc" id="L86" title="1 of 2 branches missed.">        if(file.exists()) {</span>
<span class="fc" id="L87">            file.delete();</span>
        }
<span class="fc" id="L89">    }</span>

    @Override
    public void add(final URI uri, final HttpCookie cookie) {
<span class="fc" id="L93">        assertLive();</span>
<span class="fc" id="L94">        final Key key = Key.make(uri, cookie);</span>
<span class="fc" id="L95">        add(key, cookie);</span>
<span class="fc bfc" id="L96" title="All 2 branches covered.">        if(cookie.getMaxAge() != -1L) {</span>
<span class="fc" id="L97">            store(key, cookie);</span>
        }
<span class="fc" id="L99">    }</span>

    @Override
    public boolean remove(final URI uri, final HttpCookie cookie) {
<span class="fc" id="L103">        assertLive();</span>
<span class="fc" id="L104">        return remove(Key.make(uri, cookie));</span>
    }

    @Override
    public boolean removeAll() {
<span class="fc" id="L109">        assertLive();</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">        final boolean ret = all.size() &gt; 0;</span>
<span class="fc bfc" id="L111" title="All 2 branches covered.">        for(Map.Entry&lt;Key,HttpCookie&gt; entry : all.entrySet()) {</span>
<span class="fc" id="L112">            remove(entry.getKey());</span>
<span class="fc" id="L113">        }</span>

<span class="fc" id="L115">        return ret;</span>
    }

    @Override
    public boolean remove(final Key key) {
<span class="fc" id="L120">        executor.execute(() -&gt; withLock(key, () -&gt; deleteFile(key)));</span>
<span class="fc" id="L121">        return super.remove(key);</span>
    }

    private static String clean(final String str) {
<span class="fc bfc" id="L125" title="All 2 branches covered.">        if(str == null) {</span>
<span class="fc" id="L126">            return &quot;&quot;;</span>
        }
        
<span class="fc" id="L129">        String ret = str;</span>
<span class="fc bfc" id="L130" title="All 2 branches covered.">        if(ret.indexOf('/') != -1) {</span>
<span class="fc" id="L131">            ret = ret.replace('/', '_');</span>
        }

<span class="pc bpc" id="L134" title="1 of 2 branches missed.">        if(ret.indexOf('\\') != -1) {</span>
<span class="nc" id="L135">            ret = ret.replace('\\', '_');</span>
        }

<span class="fc" id="L138">        return ret;</span>
    }
    
    private static String fileName(final Key key) {
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if(key instanceof UriKey) {</span>
<span class="nc" id="L143">            final UriKey uriKey = (UriKey) key;</span>
<span class="nc" id="L144">            return clean(uriKey.host) + clean(uriKey.name) + SUFFIX;</span>
        }
        else {
<span class="fc" id="L147">            final DomainKey domainKey = (DomainKey) key;</span>
<span class="fc" id="L148">            return clean(domainKey.domain) + clean(domainKey.path) + clean(domainKey.name) + SUFFIX;</span>
        }
    }

    private void store(final Key key, final HttpCookie cookie) {
<span class="fc" id="L153">        final Runnable runner = () -&gt; {</span>
<span class="fc" id="L154">            File file = new File(directory, fileName(key));</span>
            
<span class="pc" id="L156">            try(FileWriter fw = new FileWriter(file)) {</span>
<span class="fc" id="L157">                toProperties(key, cookie).store(fw, &quot;&quot;);</span>
<span class="pc bpc" id="L158" title="6 of 8 branches missed.">            }</span>
<span class="nc" id="L159">            catch(IOException ioe) {</span>
<span class="nc" id="L160">                onException.accept(ioe);</span>
<span class="fc" id="L161">            } };</span>
        
<span class="fc" id="L163">        executor.execute(() -&gt; withLock(key, runner));</span>
<span class="fc" id="L164">    }</span>

    //since readAll happens in the constructor and there is a guarantee that
    //each cookie store controls its own directory, we do not need to synchronize
    private void readAll() {
<span class="fc" id="L169">        final List&lt;CompletableFuture&lt;Void&gt;&gt; futures = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L170" title="All 2 branches covered.">        for(File file : directory.listFiles()) {</span>
            
<span class="fc" id="L172">            final Runnable loadFile = () -&gt; {</span>
<span class="pc bpc" id="L173" title="1 of 2 branches missed.">                if(file.getName().endsWith(SUFFIX)) {</span>
<span class="pc" id="L174">                    try(FileReader reader = new FileReader(file)) {</span>
<span class="fc" id="L175">                        Properties props = new Properties();</span>
<span class="fc" id="L176">                        props.load(reader);</span>
<span class="fc" id="L177">                        Map.Entry&lt;Key,HttpCookie&gt; entry = fromProperties(props);</span>
<span class="pc bpc" id="L178" title="1 of 2 branches missed.">                        if(entry != null) {</span>
<span class="fc" id="L179">                            add(entry.getKey(), entry.getValue());</span>
                        }
                        else {
<span class="nc" id="L182">                            file.delete();</span>
                        }
<span class="pc bpc" id="L184" title="6 of 8 branches missed.">                    }</span>
<span class="nc" id="L185">                    catch(IOException ioe) {</span>
<span class="nc" id="L186">                        throw new RuntimeException(ioe);</span>
<span class="fc" id="L187">                    }</span>
<span class="fc" id="L188">                } };</span>

<span class="fc" id="L190">            futures.add(CompletableFuture.runAsync(loadFile, executor));</span>
        }

        try {
<span class="fc" id="L194">            CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).get();</span>
        }
<span class="nc" id="L196">        catch(InterruptedException | ExecutionException e) {</span>
<span class="nc" id="L197">            throw new RuntimeException(e);</span>
<span class="fc" id="L198">        }</span>
<span class="fc" id="L199">    }</span>

    private void ifNotNull(final Properties props, final String key, final String value) {
<span class="fc bfc" id="L202" title="All 2 branches covered.">        if(value != null) {</span>
<span class="fc" id="L203">            props.setProperty(key, value);</span>
        }
<span class="fc" id="L205">    }</span>

    private Properties keyProperties(final Key key) {
<span class="fc" id="L208">        final Properties props = new Properties();</span>
<span class="fc" id="L209">        props.setProperty(&quot;keyType&quot;, key.getKeyType());</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">        if(key instanceof UriKey) {</span>
<span class="nc" id="L211">            props.setProperty(&quot;uri&quot;, String.format(&quot;http://%s&quot;, ((UriKey) key).getURI().toString()));</span>
        }

<span class="fc" id="L214">        return props;</span>
    }

    private Properties toProperties(final Key key, final HttpCookie cookie) {
<span class="fc" id="L218">        final Properties props = keyProperties(key);</span>
        
<span class="fc" id="L220">        final Instant expires = key.createdAt.plusSeconds(cookie.getMaxAge());</span>
<span class="fc" id="L221">        props.setProperty(&quot;expires&quot;, expires.toString());</span>
<span class="fc" id="L222">        props.setProperty(&quot;name&quot;, cookie.getName());</span>
<span class="fc" id="L223">        props.setProperty(&quot;value&quot;, cookie.getValue());</span>
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if(cookie.getDomain() != null) {</span>
<span class="fc" id="L225">            props.setProperty(&quot;domain&quot;, cookie.getDomain());</span>
        }

<span class="fc" id="L228">        props.setProperty(&quot;discard&quot;, Boolean.toString(cookie.getDiscard()));</span>
<span class="fc" id="L229">        props.setProperty(&quot;secure&quot;, Boolean.toString(cookie.getSecure()));</span>
<span class="fc" id="L230">        props.setProperty(&quot;version&quot;, Integer.toString(cookie.getVersion()));</span>
<span class="fc" id="L231">        props.setProperty(&quot;httpOnly&quot;, Boolean.toString(cookie.isHttpOnly()));</span>

<span class="fc" id="L233">        ifNotNull(props, &quot;comment&quot;, cookie.getComment());</span>
<span class="fc" id="L234">        ifNotNull(props, &quot;commentURL&quot;, cookie.getCommentURL());</span>
<span class="fc" id="L235">        ifNotNull(props, &quot;path&quot;, cookie.getPath());</span>
<span class="fc" id="L236">        ifNotNull(props, &quot;portlist&quot;, cookie.getPortlist());</span>
        
<span class="fc" id="L238">        return props;</span>
    }

    private Map.Entry&lt;Key,HttpCookie&gt; fromProperties(final Properties props, final HttpCookie cookie) {
<span class="fc" id="L242">        final String keyType = props.getProperty(&quot;keyType&quot;);</span>
<span class="pc bpc" id="L243" title="1 of 2 branches missed.">        if(UriKey.uriKey(keyType)) {</span>
            try {
<span class="nc" id="L245">                return new AbstractMap.SimpleImmutableEntry&lt;&gt;(new UriKey(new URI(props.getProperty(&quot;uri&quot;)), cookie), cookie);</span>
            }
<span class="nc" id="L247">            catch(URISyntaxException e) {</span>
                //can ignore since the source should have come from a valid uri
<span class="nc" id="L249">                return null;</span>
            }
        }
        else {
<span class="fc" id="L253">            return new AbstractMap.SimpleImmutableEntry&lt;&gt;(new DomainKey(cookie), cookie);</span>
        }
    }

    private Map.Entry&lt;Key,HttpCookie&gt; fromProperties(final Properties props) {
<span class="fc" id="L258">        final Instant now = Instant.now();</span>
<span class="fc" id="L259">        final Instant expires = Instant.parse(props.getProperty(&quot;expires&quot;));</span>
<span class="pc bpc" id="L260" title="1 of 2 branches missed.">        if(now.isAfter(expires)) {</span>
<span class="nc" id="L261">            return null;</span>
        }

<span class="fc" id="L264">        final long maxAge = (expires.toEpochMilli() - now.toEpochMilli()) / 1_000L;</span>
<span class="fc" id="L265">        final String name = props.getProperty(&quot;name&quot;);</span>
<span class="fc" id="L266">        final String value = props.getProperty(&quot;value&quot;);</span>
        
<span class="fc" id="L268">        final HttpCookie cookie = new HttpCookie(name, value);</span>
<span class="fc" id="L269">        cookie.setDiscard(Boolean.valueOf(props.getProperty(&quot;discard&quot;)));</span>
<span class="fc" id="L270">        cookie.setSecure(Boolean.valueOf(props.getProperty(&quot;secure&quot;)));</span>
<span class="fc" id="L271">        cookie.setVersion(Integer.valueOf(props.getProperty(&quot;version&quot;)));</span>
<span class="fc" id="L272">        cookie.setHttpOnly(Boolean.valueOf(props.getProperty(&quot;httpOnly&quot;)));</span>

<span class="fc" id="L274">        final String domain = props.getProperty(&quot;domain&quot;, null);</span>
<span class="pc bpc" id="L275" title="1 of 2 branches missed.">        if(null != domain) cookie.setDomain(domain);</span>
        
<span class="fc" id="L277">        final String comment = props.getProperty(&quot;comment&quot;, null);</span>
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if(null != comment) cookie.setComment(comment);</span>
        
<span class="fc" id="L280">        final String commentURL = props.getProperty(&quot;commentURL&quot;, null);</span>
<span class="pc bpc" id="L281" title="1 of 2 branches missed.">        if(null != commentURL) cookie.setCommentURL(commentURL);</span>

<span class="fc" id="L283">        final String path = props.getProperty(&quot;path&quot;, null);</span>
<span class="pc bpc" id="L284" title="1 of 2 branches missed.">        if(null != path) cookie.setPath(path);</span>

<span class="fc" id="L286">        final String portlist = props.getProperty(&quot;portlist&quot;, null);</span>
<span class="pc bpc" id="L287" title="1 of 2 branches missed.">        if(null != portlist) cookie.setPortlist(portlist);</span>

<span class="fc" id="L289">        return fromProperties(props, cookie);</span>
    }

    public void shutdown() {
        //not necessary to call, but can be useful
<span class="fc" id="L294">        live = false;</span>
<span class="fc" id="L295">        inUse.remove(directory);</span>
<span class="fc" id="L296">    }</span>

    public void assertLive() {
<span class="pc bpc" id="L299" title="1 of 2 branches missed.">        if(!live) {</span>
<span class="nc" id="L300">            throw new IllegalStateException(&quot;You have already called shutdown on this object&quot;);</span>
        }
<span class="fc" id="L302">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.7.8.201612092310</span></div></body></html>